class Puzzle {
  constructor(ei = 3, ej = 3) {
    this.ei = ei; //Запоминаем индексы элемента массива,
    this.ej = ej; // в котором записана пустая строка.
  }
  // Для хранения номеров костяшек будем использовать ступенчатый массив, то есть массив массивов. Забьём его по порядку числами от одного до пятнадцати, а значение последнего элемента установим равным пустой строке. Этому элементу будет соответствовать место не занятое костяшкой.
  newGame = () => {
    let arr = [];
    for (let i = 0; i < 4; ++i) {
      arr[i] = [];
      for (let j = 0; j < 4; ++j) {
        if (i + j != 6)
          arr[i][j] = i * 4 + j + 1;
        else
          arr[i][j] = '';
      }
    }
    // Такое расположение элементов в массиве соответствует выигрышному расположению костяшек.

    // Теперь напишем код, который будет отвечать за перемешивание. Этот код тоже расположим в функции newGame. Её мы будем вызывать, как только страничка будет загружена, или когда пользователь кликнет по кнопке “New game”.
    // let ei = 3; //Запоминаем индексы элемента массива,
    // let ej = 3; // в котором записана пустая строка.
    for (let i = 0; i < 1600; ++i) { // На мой взгляд 1600 это достаточно много =)
      // Случайным образом выбираем число от 0 до 3
      switch (Math.round(3 * Math.random())) {
        /*
         * 0 соответсвует верхней соседней костяшке, 1 - правой  и т.д.
         * обратим внимание что обмен местами, например,
         * с верхней костяшкой возможен, если "пустое место"
         * не ноходится у верхней границы игрового поля. Аналогично и для
         * других соседних костяшек. При обмене изменяем переменные ei и ej.
         */
        case 0:
          if (this.ei != 0) this.swap(arr, this.ei, this.ej, --this.ei, this.ej);
          break; //up
        case 1:
          if (this.ej != 3) this.swap(arr, this.ei, this.ej, this.ei, ++this.ej);
          break; //right
        case 2:
          if (this.ei != 3) this.swap(arr, this.ei, this.ej, ++this.ei, this.ej);
          break; //down
        case 3:
          if (this.ej != 0) this.swap(arr, this.ei, this.ej, this.ei, --this.ej); //left
      }
      // Забить массив arr случайными неповторяющимися цифрами от 0 до 15 нельзя, поскольку не любое расположение костяшек можно привести к собранной комбинации.
    }

    // Теперь пишем код, с помощью которого мы сформируем таблицу, в ячейках которой будут располагаться уже перемешанные элементы массива arr. Этот код так же будет располагаться в функции newGame.
    let table = document.createElement('table'); //Cоздаём таблицу	
    for (let i = 0; i < 4; ++i) {
      let row = document.createElement('tr'); //Добавляем в неё строки
      for (let j = 0; j < 4; ++j) {
        let cell = document.createElement('td'); //Cоздаём ячейки
        cell.id = i + ' ' + j;
        /*
         * Привязываем к событию, происходящему
         * при клике по ячейке таблицы функцию
         * cellClick 
         */
        cell.onclick = this.cellClick;
        //Записываем в ячейку соответсвующий эл-т массива
        cell.innerHTML = arr[i][j];
        row.appendChild(cell); // Добавляем ячейку в строку
      }
      table.appendChild(row); // Добавляем строку в таблицу			
    }
    /*
    	 * Проверяем, нет ли у
     
    <div id="box"> дочернего эл-та.
    	 * То есть таблицы. Она уже будет на странице
    	 * если  функция newGame вызвана нажатием
    	 * кнопки "New game", а не при загрузки страницы.
    */
    let box = document.getElementById("box");
    if (box.childNodes.length > 1)
      box.removeChild(box.lastChild); //Удаляем таблицу, если она есть	
    box.appendChild(table); // Запихиваем в box table</div>
  }

  // Перемешаем элементы в массиве по правилам игры, то есть будем менять местами элемент, содержащий пустую строку, с соседним, выбранным случайно, элементом достаточно много раз. Для этого, в начале, понадобится написать функцию, которая будет менять местами два элемента массива с заданными индексами.
  swap = (arr, i1, j1, i2, j2) => {
    let t = arr[i1][j1];
    arr[i1][j1] = arr[i2][j2];
    arr[i2][j2] = t;
  }

  // При клике на ячейку таблицы необходимо менять её местами с пустой ячейкой, если она соседняя. Мы уже привязали функцию cellClick к событию, происходящему при клике по ячейке таблицы. Теперь напишем код этой функции.
  cellClick = (e) => {
    let el = e.srcElement || e.target;
    /*
     * получаем номер строки и столбца, на пересечении которых
     * расположена ячейка. Мы записали их ранее в её id ячейки.
     */
    let i = el.id.charAt(0),
      j = el.id.charAt(2);
    /*
     * Если пустая ячейка расположена в одном стобце или строке
     * с ячейкой, по которой кликнули, и расстояние между
     * этими ячейками 1, то меняем их содержимое местами
     */
    if ((i == this.ei && Math.abs(j - this.ej) == 1) || (j == this.ej && Math.abs(i - this.ei) == 1)) {
      document.getElementById(this.ei + ' ' + this.ej).innerHTML = el.innerHTML;
      el.innerHTML = '';
      //Запоминаем положение пустой ячейки
      this.ei = i;
      this.ej = j;
      var q = true;
      //Проверяем не в выигрышной ли комбинации находятся ячейки.
      for (let i = 0; i < 4; ++i)
        for (let j = 0; j < 4; ++j)
          if (i + j != 6 && document.getElementById(i + ' ' + j).innerHTML != i * 4 + j + 1) {
            q = false;
            break;
          }
      if (q) alert('Victory!');
    }
  }
}

export default Puzzle;